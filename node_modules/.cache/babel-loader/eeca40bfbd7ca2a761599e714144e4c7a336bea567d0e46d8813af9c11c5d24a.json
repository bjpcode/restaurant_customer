{"ast":null,"code":"// Offline functionality and PWA utilities\n\n// IndexedDB wrapper for offline storage\nclass OfflineStorage {\n  constructor(dbName = 'restaurant-app', version = 1) {\n    this.dbName = dbName;\n    this.version = version;\n    this.db = null;\n  }\n  async init() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Create object stores\n        if (!db.objectStoreNames.contains('pending_orders')) {\n          const orderStore = db.createObjectStore('pending_orders', {\n            keyPath: 'id'\n          });\n          orderStore.createIndex('timestamp', 'timestamp');\n        }\n        if (!db.objectStoreNames.contains('cached_menu')) {\n          const menuStore = db.createObjectStore('cached_menu', {\n            keyPath: 'id'\n          });\n          menuStore.createIndex('category', 'category');\n        }\n        if (!db.objectStoreNames.contains('user_sessions')) {\n          db.createObjectStore('user_sessions', {\n            keyPath: 'sessionId'\n          });\n        }\n        if (!db.objectStoreNames.contains('app_data')) {\n          db.createObjectStore('app_data', {\n            keyPath: 'key'\n          });\n        }\n      };\n    });\n  }\n  async add(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.add({\n        ...data,\n        timestamp: Date.now()\n      });\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async get(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async getAll(storeName) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async update(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.put({\n        ...data,\n        updated_at: Date.now()\n      });\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async delete(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async clear(storeName) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    return new Promise((resolve, reject) => {\n      const request = store.clear();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n}\n\n// Create storage instance\nexport const offlineStorage = new OfflineStorage();\n\n// Offline order queue management\nexport const offlineOrderQueue = {\n  async addPendingOrder(orderData) {\n    try {\n      await offlineStorage.init();\n      const pendingOrder = {\n        id: `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...orderData,\n        status: 'pending_sync',\n        created_offline: true,\n        retry_count: 0\n      };\n      await offlineStorage.add('pending_orders', pendingOrder);\n      return pendingOrder;\n    } catch (error) {\n      console.error('Failed to store pending order:', error);\n      throw error;\n    }\n  },\n  async getPendingOrders() {\n    try {\n      await offlineStorage.init();\n      return await offlineStorage.getAll('pending_orders');\n    } catch (error) {\n      console.error('Failed to get pending orders:', error);\n      return [];\n    }\n  },\n  async syncPendingOrders() {\n    const pendingOrders = await this.getPendingOrders();\n    const syncResults = [];\n    for (const order of pendingOrders) {\n      try {\n        // Attempt to sync with server\n        const response = await fetch('/api/orders', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            ...order,\n            offline_id: order.id\n          })\n        });\n        if (response.ok) {\n          const syncedOrder = await response.json();\n          await offlineStorage.delete('pending_orders', order.id);\n          syncResults.push({\n            success: true,\n            order: syncedOrder\n          });\n        } else {\n          // Increment retry count\n          await offlineStorage.update('pending_orders', {\n            ...order,\n            retry_count: order.retry_count + 1,\n            last_retry: Date.now()\n          });\n          syncResults.push({\n            success: false,\n            error: 'Server error',\n            order\n          });\n        }\n      } catch (error) {\n        console.error('Failed to sync order:', order.id, error);\n        syncResults.push({\n          success: false,\n          error: error.message,\n          order\n        });\n      }\n    }\n    return syncResults;\n  },\n  async retryFailedOrders() {\n    const pendingOrders = await this.getPendingOrders();\n    const failedOrders = pendingOrders.filter(order => order.retry_count < 3 && (!order.last_retry || Date.now() - order.last_retry > 30000) // 30 second delay\n    );\n    if (failedOrders.length > 0) {\n      return await this.syncPendingOrders();\n    }\n    return [];\n  }\n};\n\n// Offline menu caching\nexport const offlineMenuCache = {\n  async cacheMenu(menuItems) {\n    try {\n      await offlineStorage.init();\n\n      // Clear existing cache\n      await offlineStorage.clear('cached_menu');\n\n      // Cache new menu items\n      for (const item of menuItems) {\n        await offlineStorage.add('cached_menu', {\n          ...item,\n          cached_at: Date.now()\n        });\n      }\n\n      // Store cache metadata\n      await offlineStorage.update('app_data', {\n        key: 'menu_cache_info',\n        last_updated: Date.now(),\n        item_count: menuItems.length\n      });\n    } catch (error) {\n      console.error('Failed to cache menu:', error);\n    }\n  },\n  async getCachedMenu() {\n    try {\n      await offlineStorage.init();\n      const cachedItems = await offlineStorage.getAll('cached_menu');\n\n      // Check if cache is still valid (24 hours)\n      const cacheInfo = await offlineStorage.get('app_data', 'menu_cache_info');\n      if (cacheInfo && Date.now() - cacheInfo.last_updated > 24 * 60 * 60 * 1000) {\n        return null; // Cache expired\n      }\n      return cachedItems;\n    } catch (error) {\n      console.error('Failed to get cached menu:', error);\n      return null;\n    }\n  },\n  async isCacheValid() {\n    try {\n      const cacheInfo = await offlineStorage.get('app_data', 'menu_cache_info');\n      return cacheInfo && Date.now() - cacheInfo.last_updated < 24 * 60 * 60 * 1000;\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\n// Network status monitoring\nexport const networkMonitor = {\n  isOnline: navigator.onLine,\n  listeners: new Set(),\n  init() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.notifyListeners(true);\n      this.handleOnline();\n    });\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.notifyListeners(false);\n      this.handleOffline();\n    });\n  },\n  addListener(callback) {\n    this.listeners.add(callback);\n    return () => this.listeners.delete(callback);\n  },\n  notifyListeners(status) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Network listener error:', error);\n      }\n    });\n  },\n  async handleOnline() {\n    console.log('Connection restored - syncing data...');\n    try {\n      // Sync pending orders\n      const syncResults = await offlineOrderQueue.syncPendingOrders();\n      if (syncResults.length > 0) {\n        const successCount = syncResults.filter(r => r.success).length;\n        const failureCount = syncResults.filter(r => !r.success).length;\n        console.log(`Sync completed: ${successCount} successful, ${failureCount} failed`);\n\n        // Notify user\n        if (window.showNotification) {\n          window.showNotification({\n            type: successCount > 0 ? 'success' : 'warning',\n            message: `${successCount} orders synced successfully${failureCount > 0 ? `, ${failureCount} failed` : ''}`,\n            duration: 5000\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Sync failed:', error);\n    }\n  },\n  handleOffline() {\n    console.log('Connection lost - entering offline mode...');\n\n    // Notify user\n    if (window.showNotification) {\n      window.showNotification({\n        type: 'warning',\n        message: 'You are now offline. Orders will be saved and synced when connection is restored.',\n        duration: 5000\n      });\n    }\n  }\n};\n\n// PWA installation helpers\nexport const pwaHelpers = {\n  deferredPrompt: null,\n  init() {\n    // Listen for the install prompt\n    window.addEventListener('beforeinstallprompt', e => {\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.showInstallButton();\n    });\n\n    // Listen for app installed\n    window.addEventListener('appinstalled', () => {\n      console.log('PWA installed');\n      this.hideInstallButton();\n      this.deferredPrompt = null;\n    });\n  },\n  async promptInstall() {\n    if (!this.deferredPrompt) {\n      return false;\n    }\n    this.deferredPrompt.prompt();\n    const choiceResult = await this.deferredPrompt.userChoice;\n    if (choiceResult.outcome === 'accepted') {\n      console.log('User accepted the install prompt');\n    } else {\n      console.log('User dismissed the install prompt');\n    }\n    this.deferredPrompt = null;\n    return choiceResult.outcome === 'accepted';\n  },\n  showInstallButton() {\n    // Show install button in UI\n    const installButton = document.getElementById('pwa-install-button');\n    if (installButton) {\n      installButton.style.display = 'block';\n    }\n  },\n  hideInstallButton() {\n    // Hide install button\n    const installButton = document.getElementById('pwa-install-button');\n    if (installButton) {\n      installButton.style.display = 'none';\n    }\n  },\n  isInstalled() {\n    return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;\n  }\n};\n\n// Background sync for offline functionality\nexport const backgroundSync = {\n  async register(tag, data) {\n    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n      try {\n        const registration = await navigator.serviceWorker.ready;\n\n        // Store data for sync\n        await offlineStorage.init();\n        await offlineStorage.update('app_data', {\n          key: `sync_${tag}`,\n          data,\n          timestamp: Date.now()\n        });\n\n        // Register background sync\n        return registration.sync.register(tag);\n      } catch (error) {\n        console.error('Background sync registration failed:', error);\n        return false;\n      }\n    }\n    return false;\n  },\n  async getSyncData(tag) {\n    try {\n      await offlineStorage.init();\n      const syncData = await offlineStorage.get('app_data', `sync_${tag}`);\n      return (syncData === null || syncData === void 0 ? void 0 : syncData.data) || null;\n    } catch (error) {\n      console.error('Failed to get sync data:', error);\n      return null;\n    }\n  },\n  async clearSyncData(tag) {\n    try {\n      await offlineStorage.init();\n      await offlineStorage.delete('app_data', `sync_${tag}`);\n    } catch (error) {\n      console.error('Failed to clear sync data:', error);\n    }\n  }\n};\n\n// Initialize offline functionality\nexport const initOfflineSupport = async () => {\n  try {\n    // Initialize storage\n    await offlineStorage.init();\n\n    // Initialize network monitoring\n    networkMonitor.init();\n\n    // Initialize PWA helpers\n    pwaHelpers.init();\n\n    // Set up periodic sync retry\n    setInterval(() => {\n      if (networkMonitor.isOnline) {\n        offlineOrderQueue.retryFailedOrders();\n      }\n    }, 60000); // Check every minute\n\n    console.log('Offline support initialized');\n    return true;\n  } catch (error) {\n    console.error('Failed to initialize offline support:', error);\n    return false;\n  }\n};\n\n// Export all offline utilities\nexport default {\n  storage: offlineStorage,\n  orders: offlineOrderQueue,\n  menu: offlineMenuCache,\n  network: networkMonitor,\n  pwa: pwaHelpers,\n  sync: backgroundSync,\n  init: initOfflineSupport\n};","map":{"version":3,"names":["OfflineStorage","constructor","dbName","version","db","init","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","target","objectStoreNames","contains","orderStore","createObjectStore","keyPath","createIndex","menuStore","add","storeName","data","transaction","store","objectStore","timestamp","Date","now","get","key","getAll","update","put","updated_at","delete","clear","offlineStorage","offlineOrderQueue","addPendingOrder","orderData","pendingOrder","id","Math","random","toString","substr","status","created_offline","retry_count","console","getPendingOrders","syncPendingOrders","pendingOrders","syncResults","order","response","fetch","method","headers","body","JSON","stringify","offline_id","ok","syncedOrder","json","push","success","last_retry","message","retryFailedOrders","failedOrders","filter","length","offlineMenuCache","cacheMenu","menuItems","item","cached_at","last_updated","item_count","getCachedMenu","cachedItems","cacheInfo","isCacheValid","networkMonitor","isOnline","navigator","onLine","listeners","Set","window","addEventListener","notifyListeners","handleOnline","handleOffline","addListener","callback","forEach","log","successCount","r","failureCount","showNotification","type","duration","pwaHelpers","deferredPrompt","e","preventDefault","showInstallButton","hideInstallButton","promptInstall","prompt","choiceResult","userChoice","outcome","installButton","document","getElementById","style","display","isInstalled","matchMedia","matches","standalone","backgroundSync","register","tag","ServiceWorkerRegistration","prototype","registration","serviceWorker","ready","sync","getSyncData","syncData","clearSyncData","initOfflineSupport","setInterval","storage","orders","menu","network","pwa"],"sources":["C:/Users/baij/Desktop/Work/Business/restuarant/customer/src/utils/offline.js"],"sourcesContent":["// Offline functionality and PWA utilities\n\n// IndexedDB wrapper for offline storage\nclass OfflineStorage {\n  constructor(dbName = 'restaurant-app', version = 1) {\n    this.dbName = dbName;\n    this.version = version;\n    this.db = null;\n  }\n\n  async init() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Create object stores\n        if (!db.objectStoreNames.contains('pending_orders')) {\n          const orderStore = db.createObjectStore('pending_orders', { keyPath: 'id' });\n          orderStore.createIndex('timestamp', 'timestamp');\n        }\n        \n        if (!db.objectStoreNames.contains('cached_menu')) {\n          const menuStore = db.createObjectStore('cached_menu', { keyPath: 'id' });\n          menuStore.createIndex('category', 'category');\n        }\n        \n        if (!db.objectStoreNames.contains('user_sessions')) {\n          db.createObjectStore('user_sessions', { keyPath: 'sessionId' });\n        }\n        \n        if (!db.objectStoreNames.contains('app_data')) {\n          db.createObjectStore('app_data', { keyPath: 'key' });\n        }\n      };\n    });\n  }\n\n  async add(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.add({\n        ...data,\n        timestamp: Date.now()\n      });\n      \n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async get(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async getAll(storeName) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async update(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.put({\n        ...data,\n        updated_at: Date.now()\n      });\n      \n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async delete(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async clear(storeName) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.clear();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n}\n\n// Create storage instance\nexport const offlineStorage = new OfflineStorage();\n\n// Offline order queue management\nexport const offlineOrderQueue = {\n  async addPendingOrder(orderData) {\n    try {\n      await offlineStorage.init();\n      const pendingOrder = {\n        id: `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        ...orderData,\n        status: 'pending_sync',\n        created_offline: true,\n        retry_count: 0\n      };\n      \n      await offlineStorage.add('pending_orders', pendingOrder);\n      return pendingOrder;\n    } catch (error) {\n      console.error('Failed to store pending order:', error);\n      throw error;\n    }\n  },\n\n  async getPendingOrders() {\n    try {\n      await offlineStorage.init();\n      return await offlineStorage.getAll('pending_orders');\n    } catch (error) {\n      console.error('Failed to get pending orders:', error);\n      return [];\n    }\n  },\n\n  async syncPendingOrders() {\n    const pendingOrders = await this.getPendingOrders();\n    const syncResults = [];\n\n    for (const order of pendingOrders) {\n      try {\n        // Attempt to sync with server\n        const response = await fetch('/api/orders', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            ...order,\n            offline_id: order.id\n          })\n        });\n\n        if (response.ok) {\n          const syncedOrder = await response.json();\n          await offlineStorage.delete('pending_orders', order.id);\n          syncResults.push({ success: true, order: syncedOrder });\n        } else {\n          // Increment retry count\n          await offlineStorage.update('pending_orders', {\n            ...order,\n            retry_count: order.retry_count + 1,\n            last_retry: Date.now()\n          });\n          syncResults.push({ success: false, error: 'Server error', order });\n        }\n      } catch (error) {\n        console.error('Failed to sync order:', order.id, error);\n        syncResults.push({ success: false, error: error.message, order });\n      }\n    }\n\n    return syncResults;\n  },\n\n  async retryFailedOrders() {\n    const pendingOrders = await this.getPendingOrders();\n    const failedOrders = pendingOrders.filter(order => \n      order.retry_count < 3 && \n      (!order.last_retry || Date.now() - order.last_retry > 30000) // 30 second delay\n    );\n\n    if (failedOrders.length > 0) {\n      return await this.syncPendingOrders();\n    }\n\n    return [];\n  }\n};\n\n// Offline menu caching\nexport const offlineMenuCache = {\n  async cacheMenu(menuItems) {\n    try {\n      await offlineStorage.init();\n      \n      // Clear existing cache\n      await offlineStorage.clear('cached_menu');\n      \n      // Cache new menu items\n      for (const item of menuItems) {\n        await offlineStorage.add('cached_menu', {\n          ...item,\n          cached_at: Date.now()\n        });\n      }\n      \n      // Store cache metadata\n      await offlineStorage.update('app_data', {\n        key: 'menu_cache_info',\n        last_updated: Date.now(),\n        item_count: menuItems.length\n      });\n    } catch (error) {\n      console.error('Failed to cache menu:', error);\n    }\n  },\n\n  async getCachedMenu() {\n    try {\n      await offlineStorage.init();\n      const cachedItems = await offlineStorage.getAll('cached_menu');\n      \n      // Check if cache is still valid (24 hours)\n      const cacheInfo = await offlineStorage.get('app_data', 'menu_cache_info');\n      if (cacheInfo && Date.now() - cacheInfo.last_updated > 24 * 60 * 60 * 1000) {\n        return null; // Cache expired\n      }\n      \n      return cachedItems;\n    } catch (error) {\n      console.error('Failed to get cached menu:', error);\n      return null;\n    }\n  },\n\n  async isCacheValid() {\n    try {\n      const cacheInfo = await offlineStorage.get('app_data', 'menu_cache_info');\n      return cacheInfo && Date.now() - cacheInfo.last_updated < 24 * 60 * 60 * 1000;\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\n// Network status monitoring\nexport const networkMonitor = {\n  isOnline: navigator.onLine,\n  listeners: new Set(),\n\n  init() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.notifyListeners(true);\n      this.handleOnline();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.notifyListeners(false);\n      this.handleOffline();\n    });\n  },\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    return () => this.listeners.delete(callback);\n  },\n\n  notifyListeners(status) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Network listener error:', error);\n      }\n    });\n  },\n\n  async handleOnline() {\n    console.log('Connection restored - syncing data...');\n    \n    try {\n      // Sync pending orders\n      const syncResults = await offlineOrderQueue.syncPendingOrders();\n      \n      if (syncResults.length > 0) {\n        const successCount = syncResults.filter(r => r.success).length;\n        const failureCount = syncResults.filter(r => !r.success).length;\n        \n        console.log(`Sync completed: ${successCount} successful, ${failureCount} failed`);\n        \n        // Notify user\n        if (window.showNotification) {\n          window.showNotification({\n            type: successCount > 0 ? 'success' : 'warning',\n            message: `${successCount} orders synced successfully${failureCount > 0 ? `, ${failureCount} failed` : ''}`,\n            duration: 5000\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Sync failed:', error);\n    }\n  },\n\n  handleOffline() {\n    console.log('Connection lost - entering offline mode...');\n    \n    // Notify user\n    if (window.showNotification) {\n      window.showNotification({\n        type: 'warning',\n        message: 'You are now offline. Orders will be saved and synced when connection is restored.',\n        duration: 5000\n      });\n    }\n  }\n};\n\n// PWA installation helpers\nexport const pwaHelpers = {\n  deferredPrompt: null,\n\n  init() {\n    // Listen for the install prompt\n    window.addEventListener('beforeinstallprompt', (e) => {\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.showInstallButton();\n    });\n\n    // Listen for app installed\n    window.addEventListener('appinstalled', () => {\n      console.log('PWA installed');\n      this.hideInstallButton();\n      this.deferredPrompt = null;\n    });\n  },\n\n  async promptInstall() {\n    if (!this.deferredPrompt) {\n      return false;\n    }\n\n    this.deferredPrompt.prompt();\n    const choiceResult = await this.deferredPrompt.userChoice;\n    \n    if (choiceResult.outcome === 'accepted') {\n      console.log('User accepted the install prompt');\n    } else {\n      console.log('User dismissed the install prompt');\n    }\n\n    this.deferredPrompt = null;\n    return choiceResult.outcome === 'accepted';\n  },\n\n  showInstallButton() {\n    // Show install button in UI\n    const installButton = document.getElementById('pwa-install-button');\n    if (installButton) {\n      installButton.style.display = 'block';\n    }\n  },\n\n  hideInstallButton() {\n    // Hide install button\n    const installButton = document.getElementById('pwa-install-button');\n    if (installButton) {\n      installButton.style.display = 'none';\n    }\n  },\n\n  isInstalled() {\n    return window.matchMedia('(display-mode: standalone)').matches ||\n           window.navigator.standalone === true;\n  }\n};\n\n// Background sync for offline functionality\nexport const backgroundSync = {\n  async register(tag, data) {\n    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n      try {\n        const registration = await navigator.serviceWorker.ready;\n        \n        // Store data for sync\n        await offlineStorage.init();\n        await offlineStorage.update('app_data', {\n          key: `sync_${tag}`,\n          data,\n          timestamp: Date.now()\n        });\n        \n        // Register background sync\n        return registration.sync.register(tag);\n      } catch (error) {\n        console.error('Background sync registration failed:', error);\n        return false;\n      }\n    }\n    return false;\n  },\n\n  async getSyncData(tag) {\n    try {\n      await offlineStorage.init();\n      const syncData = await offlineStorage.get('app_data', `sync_${tag}`);\n      return syncData?.data || null;\n    } catch (error) {\n      console.error('Failed to get sync data:', error);\n      return null;\n    }\n  },\n\n  async clearSyncData(tag) {\n    try {\n      await offlineStorage.init();\n      await offlineStorage.delete('app_data', `sync_${tag}`);\n    } catch (error) {\n      console.error('Failed to clear sync data:', error);\n    }\n  }\n};\n\n// Initialize offline functionality\nexport const initOfflineSupport = async () => {\n  try {\n    // Initialize storage\n    await offlineStorage.init();\n    \n    // Initialize network monitoring\n    networkMonitor.init();\n    \n    // Initialize PWA helpers\n    pwaHelpers.init();\n    \n    // Set up periodic sync retry\n    setInterval(() => {\n      if (networkMonitor.isOnline) {\n        offlineOrderQueue.retryFailedOrders();\n      }\n    }, 60000); // Check every minute\n    \n    console.log('Offline support initialized');\n    return true;\n  } catch (error) {\n    console.error('Failed to initialize offline support:', error);\n    return false;\n  }\n};\n\n// Export all offline utilities\nexport default {\n  storage: offlineStorage,\n  orders: offlineOrderQueue,\n  menu: offlineMenuCache,\n  network: networkMonitor,\n  pwa: pwaHelpers,\n  sync: backgroundSync,\n  init: initOfflineSupport\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}