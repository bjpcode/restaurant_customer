{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useMemo } from 'react';\nimport { fetchMenu, subscribeToMenuUpdates } from '../services/supabase';\nimport { menuCache } from '../services/api';\nconst CATEGORIES = ['all', 'meat', 'vegetable', 'sauces', 'desserts', 'drinks'];\nconst useMenu = () => {\n  _s();\n  const [menuItems, setMenuItems] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [lastFetch, setLastFetch] = useState(null);\n\n  // Fetch menu data\n  const fetchMenuData = useCallback(async (useCache = true) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Check cache first\n      if (useCache) {\n        const cachedMenu = menuCache.get('menu');\n        if (cachedMenu) {\n          setMenuItems(cachedMenu);\n          setLoading(false);\n          return cachedMenu;\n        }\n      }\n      const data = await fetchMenu();\n      setMenuItems(data);\n      setLastFetch(Date.now());\n\n      // Cache the data\n      menuCache.set('menu', data);\n      return data;\n    } catch (err) {\n      console.error('Error fetching menu:', err);\n      setError(err.message || 'Failed to load menu');\n\n      // Try to use cached data as fallback\n      const cachedMenu = menuCache.get('menu');\n      if (cachedMenu) {\n        setMenuItems(cachedMenu);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Refetch menu data (force refresh)\n  const refetchMenu = useCallback(() => {\n    return fetchMenuData(false);\n  }, [fetchMenuData]);\n\n  // Filter menu items by category\n  const filteredByCategory = useMemo(() => {\n    if (selectedCategory === 'all') {\n      return menuItems;\n    }\n    return menuItems.filter(item => item.category === selectedCategory);\n  }, [menuItems, selectedCategory]);\n\n  // Search menu items\n  const filteredMenuItems = useMemo(() => {\n    if (!searchQuery.trim()) {\n      return filteredByCategory;\n    }\n    const query = searchQuery.toLowerCase().trim();\n    return filteredByCategory.filter(item => {\n      var _item$description;\n      return item.name.toLowerCase().includes(query) || ((_item$description = item.description) === null || _item$description === void 0 ? void 0 : _item$description.toLowerCase().includes(query)) || item.category.toLowerCase().includes(query);\n    });\n  }, [filteredByCategory, searchQuery]);\n\n  // Group menu items by category\n  const menuItemsByCategory = useMemo(() => {\n    const grouped = filteredMenuItems.reduce((acc, item) => {\n      const category = item.category;\n      if (!acc[category]) {\n        acc[category] = [];\n      }\n      acc[category].push(item);\n      return acc;\n    }, {});\n\n    // Sort categories by predefined order\n    const sortedGrouped = {};\n    CATEGORIES.forEach(category => {\n      if (category !== 'all' && grouped[category]) {\n        sortedGrouped[category] = grouped[category];\n      }\n    });\n    return sortedGrouped;\n  }, [filteredMenuItems]);\n\n  // Get available categories (categories that have items)\n  const availableCategories = useMemo(() => {\n    const categories = new Set(menuItems.map(item => item.category));\n    return CATEGORIES.filter(category => category === 'all' || categories.has(category));\n  }, [menuItems]);\n\n  // Get category item counts\n  const categoryCounts = useMemo(() => {\n    const counts = {\n      all: menuItems.length\n    };\n    menuItems.forEach(item => {\n      counts[item.category] = (counts[item.category] || 0) + 1;\n    });\n    return counts;\n  }, [menuItems]);\n\n  // Find menu item by ID\n  const getMenuItem = useCallback(id => {\n    return menuItems.find(item => item.id === id);\n  }, [menuItems]);\n\n  // Check if items are available\n  const checkItemsAvailability = useCallback(itemIds => {\n    const unavailableItems = itemIds.filter(id => {\n      const item = getMenuItem(id);\n      return !item || !item.is_available;\n    });\n    return {\n      allAvailable: unavailableItems.length === 0,\n      unavailableItems\n    };\n  }, [getMenuItem]);\n\n  // Search functionality\n  const searchMenu = useCallback(query => {\n    setSearchQuery(query);\n  }, []);\n\n  // Category filtering\n  const filterByCategory = useCallback(category => {\n    if (CATEGORIES.includes(category)) {\n      setSelectedCategory(category);\n    }\n  }, []);\n\n  // Clear search and filters\n  const clearFilters = useCallback(() => {\n    setSearchQuery('');\n    setSelectedCategory('all');\n  }, []);\n\n  // Get popular items (mock implementation - in real app, this would come from analytics)\n  const popularItems = useMemo(() => {\n    return menuItems.filter(item => item.is_available).sort(() => Math.random() - 0.5) // Random for demo\n    .slice(0, 6);\n  }, [menuItems]);\n\n  // Get featured items (items with images)\n  const featuredItems = useMemo(() => {\n    return menuItems.filter(item => item.is_available && item.image_url);\n  }, [menuItems]);\n\n  // Initialize menu data on mount\n  useEffect(() => {\n    fetchMenuData();\n  }, [fetchMenuData]);\n\n  // Set up real-time subscriptions\n  useEffect(() => {\n    const subscription = subscribeToMenuUpdates(payload => {\n      console.log('Menu update received:', payload);\n\n      // Handle different types of changes\n      switch (payload.eventType) {\n        case 'INSERT':\n          setMenuItems(prev => [...prev, payload.new]);\n          break;\n        case 'UPDATE':\n          setMenuItems(prev => prev.map(item => item.id === payload.new.id ? payload.new : item));\n          break;\n        case 'DELETE':\n          setMenuItems(prev => prev.filter(item => item.id !== payload.old.id));\n          break;\n        default:\n          // Refetch on unknown changes\n          refetchMenu();\n      }\n\n      // Clear cache on updates\n      menuCache.clear();\n    });\n    return () => {\n      if (subscription) {\n        subscription.unsubscribe();\n      }\n    };\n  }, [refetchMenu]);\n  return {\n    // Data\n    menuItems: filteredMenuItems,\n    allMenuItems: menuItems,\n    menuItemsByCategory,\n    availableCategories,\n    categoryCounts,\n    popularItems,\n    featuredItems,\n    // State\n    loading,\n    error,\n    selectedCategory,\n    searchQuery,\n    lastFetch,\n    // Actions\n    refetchMenu,\n    searchMenu,\n    filterByCategory,\n    clearFilters,\n    getMenuItem,\n    checkItemsAvailability,\n    // Utilities\n    isDataStale: lastFetch && Date.now() - lastFetch > 300000,\n    // 5 minutes\n    isEmpty: !loading && menuItems.length === 0,\n    hasResults: filteredMenuItems.length > 0\n  };\n};\n_s(useMenu, \"dzSVW4q3y3CNvLpjiAaP1J/PnIo=\");\nexport default useMenu;","map":{"version":3,"names":["useState","useEffect","useCallback","useMemo","fetchMenu","subscribeToMenuUpdates","menuCache","CATEGORIES","useMenu","_s","menuItems","setMenuItems","loading","setLoading","error","setError","selectedCategory","setSelectedCategory","searchQuery","setSearchQuery","lastFetch","setLastFetch","fetchMenuData","useCache","cachedMenu","get","data","Date","now","set","err","console","message","refetchMenu","filteredByCategory","filter","item","category","filteredMenuItems","trim","query","toLowerCase","_item$description","name","includes","description","menuItemsByCategory","grouped","reduce","acc","push","sortedGrouped","forEach","availableCategories","categories","Set","map","has","categoryCounts","counts","all","length","getMenuItem","id","find","checkItemsAvailability","itemIds","unavailableItems","is_available","allAvailable","searchMenu","filterByCategory","clearFilters","popularItems","sort","Math","random","slice","featuredItems","image_url","subscription","payload","log","eventType","prev","new","old","clear","unsubscribe","allMenuItems","isDataStale","isEmpty","hasResults"],"sources":["C:/Users/baij/Desktop/Work/Business/restuarant/customer/src/hooks/useMenu.js"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { fetchMenu, subscribeToMenuUpdates } from '../services/supabase';\nimport { menuCache } from '../services/api';\n\nconst CATEGORIES = ['all', 'meat', 'vegetable', 'sauces', 'desserts', 'drinks'];\n\nconst useMenu = () => {\n  const [menuItems, setMenuItems] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [lastFetch, setLastFetch] = useState(null);\n\n  // Fetch menu data\n  const fetchMenuData = useCallback(async (useCache = true) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Check cache first\n      if (useCache) {\n        const cachedMenu = menuCache.get('menu');\n        if (cachedMenu) {\n          setMenuItems(cachedMenu);\n          setLoading(false);\n          return cachedMenu;\n        }\n      }\n\n      const data = await fetchMenu();\n      setMenuItems(data);\n      setLastFetch(Date.now());\n      \n      // Cache the data\n      menuCache.set('menu', data);\n      \n      return data;\n    } catch (err) {\n      console.error('Error fetching menu:', err);\n      setError(err.message || 'Failed to load menu');\n      \n      // Try to use cached data as fallback\n      const cachedMenu = menuCache.get('menu');\n      if (cachedMenu) {\n        setMenuItems(cachedMenu);\n      }\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Refetch menu data (force refresh)\n  const refetchMenu = useCallback(() => {\n    return fetchMenuData(false);\n  }, [fetchMenuData]);\n\n  // Filter menu items by category\n  const filteredByCategory = useMemo(() => {\n    if (selectedCategory === 'all') {\n      return menuItems;\n    }\n    return menuItems.filter(item => item.category === selectedCategory);\n  }, [menuItems, selectedCategory]);\n\n  // Search menu items\n  const filteredMenuItems = useMemo(() => {\n    if (!searchQuery.trim()) {\n      return filteredByCategory;\n    }\n\n    const query = searchQuery.toLowerCase().trim();\n    return filteredByCategory.filter(item => \n      item.name.toLowerCase().includes(query) ||\n      item.description?.toLowerCase().includes(query) ||\n      item.category.toLowerCase().includes(query)\n    );\n  }, [filteredByCategory, searchQuery]);\n\n  // Group menu items by category\n  const menuItemsByCategory = useMemo(() => {\n    const grouped = filteredMenuItems.reduce((acc, item) => {\n      const category = item.category;\n      if (!acc[category]) {\n        acc[category] = [];\n      }\n      acc[category].push(item);\n      return acc;\n    }, {});\n\n    // Sort categories by predefined order\n    const sortedGrouped = {};\n    CATEGORIES.forEach(category => {\n      if (category !== 'all' && grouped[category]) {\n        sortedGrouped[category] = grouped[category];\n      }\n    });\n\n    return sortedGrouped;\n  }, [filteredMenuItems]);\n\n  // Get available categories (categories that have items)\n  const availableCategories = useMemo(() => {\n    const categories = new Set(menuItems.map(item => item.category));\n    return CATEGORIES.filter(category => \n      category === 'all' || categories.has(category)\n    );\n  }, [menuItems]);\n\n  // Get category item counts\n  const categoryCounts = useMemo(() => {\n    const counts = { all: menuItems.length };\n    \n    menuItems.forEach(item => {\n      counts[item.category] = (counts[item.category] || 0) + 1;\n    });\n\n    return counts;\n  }, [menuItems]);\n\n  // Find menu item by ID\n  const getMenuItem = useCallback((id) => {\n    return menuItems.find(item => item.id === id);\n  }, [menuItems]);\n\n  // Check if items are available\n  const checkItemsAvailability = useCallback((itemIds) => {\n    const unavailableItems = itemIds.filter(id => {\n      const item = getMenuItem(id);\n      return !item || !item.is_available;\n    });\n\n    return {\n      allAvailable: unavailableItems.length === 0,\n      unavailableItems\n    };\n  }, [getMenuItem]);\n\n  // Search functionality\n  const searchMenu = useCallback((query) => {\n    setSearchQuery(query);\n  }, []);\n\n  // Category filtering\n  const filterByCategory = useCallback((category) => {\n    if (CATEGORIES.includes(category)) {\n      setSelectedCategory(category);\n    }\n  }, []);\n\n  // Clear search and filters\n  const clearFilters = useCallback(() => {\n    setSearchQuery('');\n    setSelectedCategory('all');\n  }, []);\n\n  // Get popular items (mock implementation - in real app, this would come from analytics)\n  const popularItems = useMemo(() => {\n    return menuItems\n      .filter(item => item.is_available)\n      .sort(() => Math.random() - 0.5) // Random for demo\n      .slice(0, 6);\n  }, [menuItems]);\n\n  // Get featured items (items with images)\n  const featuredItems = useMemo(() => {\n    return menuItems.filter(item => item.is_available && item.image_url);\n  }, [menuItems]);\n\n  // Initialize menu data on mount\n  useEffect(() => {\n    fetchMenuData();\n  }, [fetchMenuData]);\n\n  // Set up real-time subscriptions\n  useEffect(() => {\n    const subscription = subscribeToMenuUpdates((payload) => {\n      console.log('Menu update received:', payload);\n      \n      // Handle different types of changes\n      switch (payload.eventType) {\n        case 'INSERT':\n          setMenuItems(prev => [...prev, payload.new]);\n          break;\n        case 'UPDATE':\n          setMenuItems(prev => \n            prev.map(item => \n              item.id === payload.new.id ? payload.new : item\n            )\n          );\n          break;\n        case 'DELETE':\n          setMenuItems(prev => \n            prev.filter(item => item.id !== payload.old.id)\n          );\n          break;\n        default:\n          // Refetch on unknown changes\n          refetchMenu();\n      }\n      \n      // Clear cache on updates\n      menuCache.clear();\n    });\n\n    return () => {\n      if (subscription) {\n        subscription.unsubscribe();\n      }\n    };\n  }, [refetchMenu]);\n\n  return {\n    // Data\n    menuItems: filteredMenuItems,\n    allMenuItems: menuItems,\n    menuItemsByCategory,\n    availableCategories,\n    categoryCounts,\n    popularItems,\n    featuredItems,\n    \n    // State\n    loading,\n    error,\n    selectedCategory,\n    searchQuery,\n    lastFetch,\n    \n    // Actions\n    refetchMenu,\n    searchMenu,\n    filterByCategory,\n    clearFilters,\n    getMenuItem,\n    checkItemsAvailability,\n    \n    // Utilities\n    isDataStale: lastFetch && (Date.now() - lastFetch > 300000), // 5 minutes\n    isEmpty: !loading && menuItems.length === 0,\n    hasResults: filteredMenuItems.length > 0\n  };\n};\n\nexport default useMenu;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}